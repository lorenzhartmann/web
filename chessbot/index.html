<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn more about how I coded my very own chess bot and how you can play it online.">
    <title>Chess Bot</title>
    <link rel="stylesheet" href="../style.css">
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300..700&display=swap" rel="stylesheet">
</head>
<body>
    <nav class="navbar">
        <div class="menuitems">
            <a href="../">Home</a>
            <a href="../quantum_cosmology/">Quantum Cosmology</a>
            <a href="" class="active">Chess Bot</a>
            <a href="../travel/" >Travel</a>
            <a href="../quiz/" >Quiz</a>
            <a href="../contact/">Contact Me</a>
        </div>
    </nav>

    <main>
        <h1>Coding a Chess Robot from scratch</h1>
        <p>Please meet Robot J. Fischer, a chess bot I coded from scratch in Python! On this page, you can find out how Robot J. Fischer was built, and how you can test it (and your chess skills) online. This project is a coding challenge I set out to complete when I caught a cold in June 2025. 
            My original goal was to code a bot that would be able to beat me at chess - we'll see how that turned out below. </p>
        <p> When I decided to tackle this project, there were a few decisions (or design choices) I made: </p>
                <ul><li>The bot had to be coded entirely by me in Python - no endgame tables, online ressources or opening books.</li>
                <li>I would not look at instructions online, or research how chess bots are usually implemented. 
                    Admittedly, I was not entirely new to the topic since I knew stories of people completing similar projects before, and I did use online ressources when I got stuck. But I figured that it
                    would still be more fun to go in blind and develop my own concepts, instead of merely implementing methods others have used long before me.</li>
                <li>I want to teach the bot to play chess like a human. Robot J. Fischer needs to learn the same basic chess principles we teach to every chess beginner, and it should not contain any unnatural methods like piece-square-tables</li>
            </ul></p>
        <h2>The evaluation function</h2>
        <p>It quickly became clear to me that the heart of my bot had to be some kind of evaluation function. This function performs a stratetic (rather than tactical) assessment of a given board and decides how good (or bad) this position is for either player.</p>
            <img src="../objects/evaluate.png" style="width: 20%;" alt="Concept of an evaluation function">
        <p>This function was the first thing I worked on. The challenge is to find the right metrics that make a chess position good for either color, and to find a way to implement them in Python in a computationally efficient way.
            The obvious starting point is the current material count, but I kept editing this function during the whole coding process to account for more factors that a human chess player would also consider:
            <ul>
                <li>How much space (= how many legal moves) each side has</li>
                <li>How well each side defends their pieces and attacks the opponents</li>
                <li>If there are any passes pawns, or pawns close to promotion</li>
                <li>How save (= close to the corner) every king is, except during the endgame</li>
                <li>During the opening phase: How well each side occupies the center with pawns develops their pieces and whether they moved their king</li>
                <li>During the final moves of the game: How well the own king is activated and the opponent's king is forced to the corner</li>
            </ul>
        I also made sure to add a small random number to the evaluation, so that the bot doesn't play the same moves in every game.</p>
        <p>Based on this evaluation function, we can already set up a minimal working example of a chess bot: Given a position, go through every legal move and play the one that maximizes the evaluation function (or minimizes it, if you are playing with the black pieces)
            Of course, this bot has a profound weakness: It cannot take the opponent's responses into account. For example, if will gladly sacrifice its queen to take your pawn, as this move will momentarily boost the evaluation in its favour.
        </p>
        <h2>Improving the search alogrithm</h2>
        <p>This immediate problem can be solved by the bot looking one move deeper. We can tell him to consider every legal move, and every legal response for each move. This will make the bot considerably stronger, but the fundamental issue remains:
            The evaluation function is not reliable if applied to positions with an "ongoing capture sequence".</p>
        <p>I came up with the following key idea: The evaluation function should not only return a numerical score, but also the information whether this score is trustworthy or not. The actual implementation of this idea was rather cumbersome, but the basic idea is to scan
            the current position for hanging pieces and capturing moves that win material at first sight. If the algorithm decides that the naive evaluation is not to be trusted, it can use these same tools to "finish" all outstanding capture sequences, finally
        arriving at a reliable evalution of the current position. </p>
        <img src="../objects/search_alg.png" style="width: 60%;" alt="Idea of the alogrithm that kicks in if the evaluation function fails">
        <p>This iterative process is the key to the search algorithm of Robert J. Fischer - it reduces blunders significantly and gives it a respectable tactical awareness.</p>
        <h2>What's next?</h2>
        <p>At this stage, the bot is already a decent chess player, and it can beat most beginners quite comfortably. The next obvious conceptual step is to increase the search depth of the bot, so that it calculates variants more deeply and reliably.
            I implemented a backtracking algorithm that allows the bot to calculate positions to arbitrary depth, even though it runs into runtime problems fairly quickly. This is why I spent a lot of time on making the bot faster. One key idea is to idetify
            a list of candidate moves, i.e. moves that are more likely to be good, and to make the bot search through these moves first. If it later finds a move that is worse than one of these candidate moves, it can discard this entire branch of the search tree
            immediately. 
        </p>
        <p>This improved the speed of the programme quite a bit, but it was still too slow to justify upgrading the search depth Ultimately, I had to settle for the original base search depth, which is increased only if the bot spots a promising tactical combination.</p>
    
        <h>Playing against Robot J. Fischer</h>

    </main>

</body>
</html>